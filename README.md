# Sparsnas
Various projects on the IKEA Sparsnäs energy monitor

# Radio Signal Analysis
This section describes how to decode the radio transmission.

The IKEA Sparsnäs consists of a sensor measuring energy led blinks. It uses a TexasInstruments CC115L transmitter, and the display-enabled receiver uses a TexasInstruments CC113L.

 * [Texas Instruments CC115L](Docs/TexasInstruments.CC115L-RF.Transmitter.On.Sensor.pdf) - Transmitter datasheet
 * [Texas Instruments CC113L](Docs/TexasInstruments.CC113L-RF.Receiver.On.Display.pdf) - Receiver datasheet
 

## Recording the signal

First, you need to have some sort of Software Defined Radio (SDR) installed on your system. There are many out there; [RTL-SDR](https://www.rtl-sdr.com/rtl-sdr-blog-v-3-dongles-user-guide/), [HackRF-One](https://greatscottgadgets.com/hackrf/), [AirSpy](https://airspy.com/products/) just to name a few.

XXX TODO: insert photo of them here

Second, you need some software to record the signal. You will find any alternatives ranging from simple commandline apps to more advanced guis. The Ikea Sparsnäs sends a signal on the 868 MHz band, and here are a few alternatives to record on that band.

```
rtl_sdr -f 868000000 -s 1024000 -g 40 > outfile.cu8

hackrf_transfer -r outfile.cs8 -f 868000000 -s 2000000

osmocom_fft -a airspy -f 868000000 -v
```

This text will not go into the details on how to install them. This text will continue assuming that you managed to record a signal to file on disk using one of the command lines above. Note: different applications stores the signal data in different formats such as *.cu8, *.cs8, *.cu16, *.cfile, etc. Common to all these formats is the sample form called ["IQ"](http://whiteboard.ping.se/SDR/IQ).

##### Open the recorded signal file in a graphical interface for analysis

 There are many different techniques and softwares for doing signal analysis. Here we will be using [Inspectrum](https://github.com/miek/inspectrum) and [DspectrumGUI](https://github.com/tresacton/dspectrumgui).

```
 inspectrum -r SampleRateInHz Filename.Ext
 inspectrum -r 1024000        outfile.cu8
```

Now begins the process of locating the signal. Browsing the horizontal timeline we finally find the following colorful signal:
![Locating the signal](Docs/00.Start.by.scrolling.until.we.find.some.signal.png?raw=true "Locating the signal")

By modifying the sliders on the left in the GUI, we can zoom in into the signal. The Y-axis is the 'FFT size' and the X-axis is the 'Zoom' which corresponds to the timeline of your signal recording. By doing this, we end up with the following result:

![Zooming into the signal](Docs/01.Isolate.the.FSK.signal.png?raw=true "Zooming into the signal")
The recording frequency of 868 MHz is represented at zero on the Y-axis. The short signal in the middle is an artifact called "DC-Spike" which is an anomaly generated by the SDR-device. But here we see two frequencies along the recording frequency. This is typical for signal modulation type ["FSK"](https://en.wikipedia.org/wiki/Frequency-shift_keying). Lets zoom in even further:

![Zooming into the signal ever further](Docs/02.Zoom.in.and.identify.upper.and.lower.FSK.frequencies.png?raw=true "Zooming into the signal ever further")
Now this certainly looks like a FSK-signal.

By right-clicking on the FSK-signal in Inspectrum we can do a "Frequency Plot":

![Right-clicking and enable frequency plot](Docs/03.RightClick.and.enable.frequency.plot.png?raw=true "Right-clicking and enable frequency plot")
![Frequency Plot](Docs/04.Frequency.plot.png?raw=true "Frequency Plot")

The frequency plot (see the green-lined graph above) show how the two frequencies changes and creates binary 1's and 0's. Right-clicking on the frequency plot graph enables us to do a "Threshold Plot" which modifies the somewhat buzzy frequency plot into a nice binary form:

![Right-clicking and enable threshold plot](Docs/05.RightClick.and.enable.threshold.plot.png?raw=true "Right-clicking and enable threshold plot")
![Threshold Plot](Docs/06.Inspect.the.binary.stream.png?raw=true "Threshold Plot")

Next up in the analysis is to determine signal characteristics like data rate of the 1's and 0's. Inspectrum helps us with that by using "cursors" which are enabled by hitting the checkbox on the left in the gui. We can here graphically position the cursors such that they align as perfectly as possible with the edges of the 1's and 0's. We do this for as long as we have what seems as valid data, ending up with 208 symbols (i.e. 1's or 0's).

![Position cursors to define the whole message](Docs/08.Position.cursors.to.define.the.whole.message.png?raw=true "Position cursors to define the whole message")

Now, if we look in the reference documentation of the transmitter CC115L, we find this packet description:
![Lookup packet format in the TI-CC113L documentation](Docs/09.Lookup.packet.format.in.the.TI-CC113L.receiver.docs.png?raw=true "Lookup packet format in the TI-CC113L documentation")

So, our green binary bit-stream should fit into this packet.

Working with binary streams can be inefficient. A more preferable form is hexadecimal. We could start counting the binary string, 8-bits at a time, but instead we use the application DspectrumGui which automates that process for us. Right-click and send the data to stdout. (For this to work it is required that you have started Inspectrum from within DspectrumGUI).
![RightClick and send symbol data back to DspectrumGui](Docs/10.RightClick.and.send.symbol.data.back.to.DspectrumGui.png?raw=true "RightClick and send symbol data back to DspectrumGui")
![Review the decoded binary stream in the DspectrumGUI](Docs/11.Review.the.decoded.binary.stream.in.the.DspectrumGui.png?raw=true "Review the decoded binary stream in the DspectrumGUI")

Here in DspectrumGUI we see the binary stream and the "Raw Binary To Hex" conversion. Now its easier to map the data into the packet format:

![Mapping the values from DspectrumGUI to the Texas Instruments packet format](Docs/12.Mapping.the.values.from.DspectrumGUI.to.the.receivers.defined.paket.format.png?raw=true "Mapping the values from DspectrumGUI to the Texas Instruments packet format")

We now want to verify that our analysis is correct. We do this by looking up the CRC-algorithm in the Texas Instruments documentation and test our values:

![Look up the CRC algorithm used in the Texas Instruments documentation and test the values](Docs/13.Look.up.the.CRC.algorithm.used.in.TI-docs.and.test.the.values.png?raw=true "Look up the CRC algorithm used in the Texas Instruments documentation and test the values")

We do a quick implementation of the algorithm in an online c++ compiler/debugger environment, and when executing it we end up with "crc checksum: 0x1204" which matches the expected crc value.

We can now go on to the next step in the analysis which is recording more data. Now since the sender and transmitter are of the Texas Instruments family CCxxxx, we use a usb hardware dongle called ["Yard Stick One"](https://greatscottgadgets.com/yardstickone/). It consists of a CC1111 chip which can be controlled using the Python-library RfCat.

To start doing this, we need to feed the things we have seen so far in the analysis into the CC1111-tranceiver. Here's how we do that:

![Determine CC1111 tranceiver parameters in RfCat](Docs/16.Determine.CC1111.tranceiver.parameters.in.RfCat.png?raw=true "Determine CC1111 tranceiver parameters in RfCat")

By starting RfCat, defining the function init(d) and calling it we have configured the CC1111-chip. To start listening we call d.RFlisten() and as you can see we start to get some packets.

However, to be able to test the packet content better, we write a small Python script. Take a moment to read it, in order to get an understanding of whats going on:

```python
#=============================================================================
# Ikea Sparsnas packet decoder using Yard Stick One along with RfCat
#=============================================================================
import sys
import readline
import rlcompleter
readline.parse_and_bind("tab: complete")
from rflib import *                           

#-----------------------------------------------------------------------------
#------------------------------ Global variables -----------------------------
#-----------------------------------------------------------------------------
d = RfCat()
Verbose = False


#-----------------------------------------------------------------------------
# Initialize radio
#-----------------------------------------------------------------------------
def init(d):
    d.setFreq(868000000)            # Main frequency
    d.setMdmModulation(MOD_2FSK)    # Modulation type
    d.setMdmChanSpc(40000)          # Channel spacing
    d.setMdmDeviatn(20000)          # Deviation
    d.setMdmNumPreamble(32)         # Number of preamble bits
    d.setMdmDRate(38391)            # Data rate
    d.setMdmSyncWord(0xD201)        # Sync Word
    d.setMdmSyncMode(1)             # 15 of 16 bits must match
    d.makePktFLEN(20)               # Packet length
    d.setMaxPower()

#-----------------------------------------------------------------------------
# Crc16 helper
#-----------------------------------------------------------------------------
def culCalcCRC(crcData, crcReg):
    CRC_POLY = 0x8005
    
    for i in xrange(0,8):
        if ((((crcReg & 0x8000) >> 8) ^ (crcData & 0x80)) & 0XFFFF) :
            crcReg = (((crcReg << 1) & 0XFFFF) ^ CRC_POLY ) & 0xFFFF
        else:
            crcReg = (crcReg << 1) & 0xFFFF
        crcData = (crcData << 1) & 0xFF
    return crcReg

#-----------------------------------------------------------------------------
# crc16
#-----------------------------------------------------------------------------
def crc16(txtBuffer, expectedChksum):
    CRC_INIT = 0xFFFF
    checksum = CRC_INIT

    hexarray = bytearray.fromhex(txtBuffer)
    for i in hexarray:
        checksum = culCalcCRC(i, checksum)

    if checksum == int(expectedChksum, 16):
        #print "(CRC OK)"
        return True
    else:
        #print "(CRC FAIL) Expected=" + expectedChksum + " Calculated=" + str(hex(checksum))
        return False

#-----------------------------------------------------------------------------
# "main"
#-----------------------------------------------------------------------------
print "Initialize modem..."
init(d)

print "Waiting for packet..."
#d.RFlisten()

#-----------------
# Read packet loop
#-----------------
while True:
    capture = ""
    
    #---------------------------------
    # Wait for a packet to be captured
    #---------------------------------
    try:
        y,z = d.RFrecv()
        capture = y.encode('hex')
        #print capture

    except ChipconUsbTimeoutException:
        pass

    #------------------------
    # When we got a packet...
    #------------------------
    if capture:

        # Extract packet content to the formal TexasInstruments packet layout
        pkt_length  = capture[0:0+2]
        pkt_address = capture[2:2+2]
        pkt_data    = ""
        for x in xrange(4, len(capture) - 4, 2):
            currElement = capture[x:x+2]
            pkt_data += currElement + " "
        pkt_crc     = capture[36:36+2] + " " + capture[38:38+2]

        # Verify crc16 accordingly to the TexasInstruments implementation
        crcBuf_str  = (pkt_length + pkt_address + pkt_data).replace(" ","")
        expectedCrc = capture[36:36+2] + capture[38:38+2]
        crcOk       = crc16(crcBuf_str, expectedCrc)

        if Verbose:
            print "pkt.length        = " + pkt_length
            print "pkt.address_field = " + pkt_address
            print "pkt.data_field    = " + pkt_data
            print "pkt.crc16         = " + pkt_crc + " (CRC verification: " + str(crcOk) + ")"
            print ""
        else:
            if crcOk:
                print "Pkt: " + pkt_length + " ",
                print  pkt_address + " ",
                print  pkt_data.replace(" ","") + " ",
                print  pkt_crc.replace(" ","")
```

When we run the script and start to get some data, we quickly identify that the packet contents does not match what is shown on the receiving display. We can therefore conclude that the packet content is scrambled in some way.

![First attempt to look for patterns in packet content](Docs/17.First.attempt.to.look.for.patterns.in.packet.content.png?raw=true "First attempt to look for patterns in packet content")
At this point, we know nothing of the internal packet layout, but we can start to identify patterns. This is a creative process which can be time consuming. First we need to list possible entities that may, or not may, be in the Data Field-part of the signal.

### Constants

 * Variable identifiers (such as data for variable X is always prepended with the constant Y)
 * Length fields (packet length, length of individual fields in the packet, etc)
 * Sync words or other "magics" 
 * Sender identifiers (addresses, serials, hardware or software versions/revisions)
 * etc

### Variables

 * Timestamps
 * Things we (in this case) see on the display
   * Current power usage seen on the display
   * Accumulative power consumption seen on the display
   * Battery life properties
 * Signal strength/RSSI if we're dealing with a two-way communication protocol
 * Extra crc's or other hashes
 * etc

The list goes on an on, but lets start with those elements for now. When identifying element-patterns we need to control the signal being sent as much as possible. Therefore we build a simple led-blinker with an Arduino board. The led is flashing at a predetermined rate which we control. Knowing the stable flash rate we can observe what kWh they translate into on the receiving display. This is a good starting point for our analysis. Other things we may consider is to hook up the sensor to a voltage cube and vary the transmitters battery voltage. A third option is to purchase several Sparsnäs devices, and decode signals from the different senders which may have different sender properties or identifiers. 

## Led blink helper tool
<img src="LedBlinkerHelperTool/LedFlasher.png"  width="200" />
<img src="LedBlinkerHelperTool/LedFlasher2.jpg"  width="246" />

You can find the source code [here](LedBlinkerHelperTool/LedFlasher.ino).

We hook up the Sparsnäs sensor to the red led on the right in the image above. Using the yellow and green push buttons we can increase or decrease the delay between led blinks, allowing us to experiment while running our RfCat on the side.

XXX TODO: continue to document the analysis here
